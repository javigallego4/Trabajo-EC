# Establecemos la velocidad de la animacion
ani.options(interval = 1)
# Coloco la ejecucion del algoritmo en una funcion para tener un codigo limpio
# (no poner esto en `saveHTML`) y para que no se muestre en el documento html
# principal, sin animar
generate_result <- function() {
return(knn.ani(
train = X_train,
test = X_test,
k = k,
cl = y_train
))
}
# Aplicamos el algoritmo, salvandolo en un fichero html para visualizarse
saveHTML(
generate_result(),
htmlfile = "kNN.html",
img.name = "k_nn",
imgdir = "images/knn"
)
getwd()
setwd('/Users/javigallego/Desktop/UGR/Cuatri\ II\ /EC/Trabajo')
library(animation)
train_data<-read.csv('titanic_train.csv', row.names=NULL); head(train_data)
train_data <- train_data[is.na(train_data$Age) == FALSE,]; head(train_data)
X_train<-train_data[train_data$Fare < 50,  c("Age", "Fare")]; head(X_train)
y_train<-train_data[train_data$Fare < 50, 'Survived']; head(y_train)
test_data<-read.csv('titanic_test.csv', row.names=NULL); head(test_data)
test_data <- test_data[(is.na(test_data$Fare) == FALSE) & (is.na(test_data$Age) == FALSE),]; head(test_data)
X_test<-test_data[X_test$Fare < 50,  c("Age", "Fare")]; head(X_test)
sum(is.na(X_test))
# Nos fijaremos en los cinco vecinos más cercanos
k <- 5
# Establecemos la velocidad de la animacion
ani.options(interval = 1)
# Coloco la ejecucion del algoritmo en una funcion para tener un codigo limpio
# (no poner esto en `saveHTML`) y para que no se muestre en el documento html
# principal, sin animar
generate_result <- function() {
return(knn.ani(
train = X_train,
test = X_test,
k = k,
cl = y_train
))
}
# Aplicamos el algoritmo, salvandolo en un fichero html para visualizarse
saveHTML(
generate_result(),
htmlfile = "kNN.html",
img.name = "k_nn",
imgdir = "images/knn"
)
getwd()
setwd('/Users/javigallego/Desktop/UGR/Cuatri\ II\ /EC/Trabajo')
library(animation)
train_data<-read.csv('titanic_train.csv', row.names=NULL); head(train_data)
train_data <- train_data[is.na(train_data$Age) == FALSE,]; head(train_data)
X_train<-train_data[train_data$Fare < 250,  c("Age", "Fare")]; head(X_train)
y_train<-train_data[train_data$Fare < 250, 'Survived']; head(y_train)
test_data<-read.csv('titanic_test.csv', row.names=NULL); head(test_data)
test_data <- test_data[(is.na(test_data$Fare) == FALSE) & (is.na(test_data$Age) == FALSE),]; head(test_data)
X_test<-test_data[X_test$Fare < 250,  c("Age", "Fare")]; head(X_test)
sum(is.na(X_test))
# Nos fijaremos en los cinco vecinos más cercanos
k <- 5
# Establecemos la velocidad de la animacion
ani.options(interval = 1)
# Coloco la ejecucion del algoritmo en una funcion para tener un codigo limpio
# (no poner esto en `saveHTML`) y para que no se muestre en el documento html
# principal, sin animar
generate_result <- function() {
return(knn.ani(
train = X_train,
test = X_test,
k = k,
cl = y_train
))
}
# Aplicamos el algoritmo, salvandolo en un fichero html para visualizarse
saveHTML(
generate_result(),
htmlfile = "kNN.html",
img.name = "k_nn",
imgdir = "images/knn"
)
getwd()
setwd('/Users/javigallego/Desktop/UGR/Cuatri\ II\ /EC/Trabajo')
library(animation)
train_data<-read.csv('titanic_train.csv', row.names=NULL); head(train_data)
train_data <- train_data[is.na(train_data$Age) == FALSE,]; head(train_data)
X_train<-train_data[train_data$Fare < 250,  c("Age", "Fare")]; head(X_train)
y_train<-train_data[train_data$Fare < 250, 'Survived']; head(y_train)
test_data<-read.csv('titanic_test.csv', row.names=NULL); head(test_data)
test_data <- test_data[(is.na(test_data$Fare) == FALSE) & (is.na(test_data$Age) == FALSE),]; head(test_data)
X_test<-test_data[test_data$Fare < 250,  c("Age", "Fare")]; head(X_test)
sum(is.na(X_test))
# Nos fijaremos en los cinco vecinos más cercanos
k <- 5
# Establecemos la velocidad de la animacion
ani.options(interval = 1)
# Coloco la ejecucion del algoritmo en una funcion para tener un codigo limpio
# (no poner esto en `saveHTML`) y para que no se muestre en el documento html
# principal, sin animar
generate_result <- function() {
return(knn.ani(
train = X_train,
test = X_test,
k = k,
cl = y_train
))
}
# Aplicamos el algoritmo, salvandolo en un fichero html para visualizarse
saveHTML(
generate_result(),
htmlfile = "kNN.html",
img.name = "k_nn",
imgdir = "images/knn"
)
getwd()
setwd('/Users/javigallego/Desktop/UGR/Cuatri\ II\ /EC/Trabajo')
library(animation)
train_data<-read.csv('titanic_train.csv', row.names=NULL); head(train_data)
train_data <- train_data[is.na(train_data$Age) == FALSE,]; head(train_data)
X_train<-train_data[(train_data$Fare>=30) & (train_data$Fare < 250),  c("Age", "Fare")]; head(X_train)
y_train<-train_data[(train_data$Fare>=30) & (train_data$Fare < 250), 'Survived']; head(y_train)
test_data<-read.csv('titanic_test.csv', row.names=NULL); head(test_data)
test_data <- test_data[(is.na(test_data$Fare) == FALSE) & (is.na(test_data$Age) == FALSE),]; head(test_data)
X_test<-test_data[(test_data$Fare>=30) & (test_data$Fare < 250),  c("Age", "Fare")]; head(X_test)
sum(is.na(X_test))
# Nos fijaremos en los cinco vecinos más cercanos
k <- 5
# Establecemos la velocidad de la animacion
ani.options(interval = 1)
# Coloco la ejecucion del algoritmo en una funcion para tener un codigo limpio
# (no poner esto en `saveHTML`) y para que no se muestre en el documento html
# principal, sin animar
generate_result <- function() {
return(knn.ani(
train = X_train,
test = X_test,
k = k,
cl = y_train
))
}
# Aplicamos el algoritmo, salvandolo en un fichero html para visualizarse
saveHTML(
generate_result(),
htmlfile = "kNN.html",
img.name = "k_nn",
imgdir = "images/knn"
)
f1 = function(x, y) x^2 + 3 * sin(y)
x <- seq(pi*-2,pi*2,length.out=100)
y <- seq(pi*-2,pi*2,length.out=100)
z <- outer(x^2,3* sin(y),`+`)
persp(x,y,z,theta = 30)
library(rgl)
install.packages('rgl')
library(rgl)
library(plotly)
install.packages('plotly')
library(plotly)
# Define the convex function of three variables
f <- function(x, y, z) {
return(-x*log(y) - (1-x)*log(1-y) + z*log(y/(1-y)))
}
# Generate a grid of x, y, z values
x <- seq(0, 1, length = 50)
y <- seq(0, 1, length = 50)
z <- seq(0, 1, length = 50)
xyz <- expand.grid(x, y, z)
f_values <- apply(xyz, 1, function(row) f(row[1], row[2], row[3]))
# Create a data frame with x, y, z, and f values
df <- data.frame(x = xyz[,1], y = xyz[,2], z = xyz[,3], f = f_values)
# Create the 3D surface plot
# Create the 3D surface plot
plot_ly(df, x = ~x, y = ~y, z = ~z, surfacecolor = ~f, colorscal
# Create the 3D surface plot
plot_ly(df, x = ~x, y = ~y, z = ~z, surfacecolor = ~f, colorscale = "Viridis", type = "surface")
#install.packages('plotly')
library(plotly)
# Define the convex function of three variables
f <- function(x, y, z) {
return(-x*log(y) - (1-x)*log(1-y) + z*log(y/(1-y)))
}
# Generate a grid of x, y, z values
x <- seq(0, 1, length = 50)
y <- seq(0, 1, length = 50)
z <- seq(0, 1, length = 50)
xyz <- expand.grid(x, y, z)
f_values <- apply(xyz, 1, function(row) f(row[1], row[2], row[3]))
# Create a data frame with x, y, z, and f values
df <- data.frame(x = xyz[,1], y = xyz[,2], z = xyz[,3], f = f_values)
# Create the 3D surface plot
plot_ly(df, x = ~x, y = ~y, z = ~z, surfacecolor = ~f, colorscale = "Viridis", type = "surface")
library(ggplot2)
# Define the function
f <- function(x, y) {
x^2 - y^2
}
# Generate the data
x <- seq(-5, 5, length.out = 100)
y <- seq(-5, 5, length.out = 100)
z <- outer(x, y, f)
# Plot the function
ggplot(melt(z), aes(x = Var1, y = Var2, fill = value)) +
geom_raster() +
scale_fill_gradient2(low = "blue", mid = "white", high = "red",
midpoint = 0, limits = c(-50, 50)) +
labs(x = "x", y = "y", title = "f(x, y) = x^2 - y^2")
fdejong <- function (x, y) {
return (x^2 + y^2)
}
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, fdejong)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "red")
saveHTML({grad.desc(fdejong, c(-10, -10, 10, 10), c(8, 8))
},htmlfile = "GD.html", img.name = "gradiente_descendiente", imgdir = "images/gradiente_descendiente")
library(animation)
saveHTML({grad.desc(fdejong, c(-10, -10, 10, 10), c(8, 8))
},htmlfile = "GD.html", img.name = "gradiente_descendiente", imgdir = "images/gradiente_descendiente")
saveHTML({grad.desc(fdejong, c(0, 0, 10, 10), c(8, 8))
},htmlfile = "GD.html", img.name = "gradiente_descendiente", imgdir = "images/gradiente_descendiente")
fdejong <- function (x, y) {
return (x^2 + y^2)
}
# Define the gradient of the function
grad.fdejong <- function(x, y) {
return(c(2*x, 2*y))
}
# Set the initial point and step size
init.point <- c(3, 4)
step.size <- 0.5
# Run gradient descent and save the animation
ani.options(interval = 0.5)
saveHTML({
grad.desc(fdejong, grad.fdejong, init.point, step.size)
}, img.name = "grad.desc_fdejong", imgdir = "images")
fdejong <- function (x, y) {
return (x^2 + y^2)
}
# Define the gradient of the function
grad.fdejong <- function(x, y) {
return(c(2*x, 2*y))
}
# Set the initial point and step size
init.point <- c(3, 4)
step.size <- 0.5
# Run gradient descent and save the animation
ani.options(interval = 0.5)
saveHTML({
grad.desc(fdejong, grad.fdejong, init.point, step.size)
}, img.name = "desc_fdejong", imgdir = "images")
fdejong <- function (x, y) {
return (x^2 + y^2)
}
# Define the gradient of the function
grad.fdejong <- function(x, y) {
return(c(2 * x, 2 * y))
}
# Set the initial point and step size
init.point <- c(3, 4)
step.size <- 0.5
# Run gradient descent and save the animation
ani.options(interval = 0.5)
saveHTML({
grad.desc(fdejong, grad.fdejong, init.point, step.size)
}, img.name = "desc_fdejong", imgdir = "images")
fdejong <- function (x, y) {
return (x^2 + y^2)
}
# Define the gradient of the function
grad.fdejong <- function(x, y) {
return(c(2 * x, 2 * y))
}
# Set the initial point and step size
init.point <- c(3, 4)
step.size <- 0.5
# Run gradient descent and save the animation
ani.options(interval = 0.5)
saveHTML({
grad.desc(fdejong, grad.fdejong, init.point, step.size)
}, img.name = "desc_fdejong", imgdir = "images")
fdejong <- function (x, y) {
return (x^2 + y^2)
}
# Define the gradient of the function
grad.fdejong <- function(x, y) {
return(c(2 * x, 2 * y))
}
# Set the initial point and step size
init.point <- c(3, 4)
step.size <- 0.5
# Run gradient descent and save the animation
ani.options(interval = 0.5)
saveHTML({
grad.desc(fdejong, init.point, step.size)
}, img.name = "desc_fdejong", imgdir = "images")
grad.desc(fdejong, init.point)
fdejong <- function (x, y) {
return (x^2 + y^2)
}
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, fdejong)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "red")
library(animation)
saveHTML({grad.desc(fdejong, c(0, 0, 10, 10))
},htmlfile = "GD.html", img.name = "gradiente_descendiente", imgdir = "images/gradiente_descendiente")
fdejong <- function (x, y) {
return (x^2 + y^2)
}
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, fdejong)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "red")
library(animation)
saveHTML(grad.desc(fdejong, c(0, 0, 10, 10))
,htmlfile = "GD.html", img.name = "gradiente_descendiente", imgdir = "images/gradiente_descendiente")
saveHTML({grad.desc(fdejong, pi * c(-2, -2, 2, 2), c(-2 * pi, 2))
},htmlfile = "GD.html", img.name = "gradiente_descendiente", imgdir = "images/gradiente_descendiente")
fdejong <- function (x, y) {
return (x^2 + y*sin(y))
}
saveHTML({grad.desc(fdejong, pi * c(-2, -2, 2, 2), c(-2 * pi, 2))
},htmlfile = "GD.html", img.name = "gradiente_descendiente", imgdir = "images/gradiente_descendiente")
f1 = function(x, y) x^2 + 3 * sin(y)
library(animation)
saveHTML({grad.desc(f1, pi * c(-2, -2, 2, 2), c(-2 * pi, 2))
},htmlfile = "GD.html", img.name = "gradiente_descendiente", imgdir = "images/gradiente_descendiente")
#> HTML file created at: GD.html
f1 = function(x, y) x^2 + 3 * y^2
library(animation)
saveHTML({grad.desc(f1, pi * c(-2, -2, 2, 2), c(-2 * pi, 2))
},htmlfile = "GD.html", img.name = "gradiente_descendiente", imgdir = "images/gradiente_descendiente")
fdejong = function(x, y) x^2 + y^2
library(animation)
saveHTML({grad.desc(fdejong, pi * c(-2, -2, 2, 2), c(-2 * pi, 2))
},htmlfile = "GD.html", img.name = "gradiente_descendiente", imgdir = "images/gradiente_descendiente")
#> HTML file created at: GD.html
library(animation)
fdejong = function(x, y) x^2 + y^2
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, fdejong)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "red")
saveHTML({grad.desc(fdejong, pi * c(-2, -2, 2, 2), c(-2 * pi, 2))
},htmlfile = "GD.html", img.name = "gradiente_descendiente", imgdir = "images/gradiente_descendiente")
#> HTML file created at: GD.html
library(animation)
fdejong = function(x, y) x^2 + y^2
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, fdejong)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "red")
saveHTML({grad.desc(fdejong, c(-10,-10,10,10), c(-2 * pi, 2))
},htmlfile = "GD_convexo.html", img.name = "gd", imgdir = "imgs/gd")
#> HTML file created at: GD.html
library(animation)
fdejong = function(x, y) x^2 + y^2
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, fdejong)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "red")
saveHTML({grad.desc(fdejong, c(-10,-10,10,10), c(8,8))
},htmlfile = "GD_convexo.html", img.name = "gd", imgdir = "imgs/gd")
#> HTML file created at: GD.html
f1 = function(x, y) x^2 + 3 * sin(y)
x <- seq(pi*-2,pi*2,length.out=100)
y <- seq(pi*-2,pi*2,length.out=100)
z <- outer(x^2,3* sin(y),`+`)
persp(x,y,z,theta = 30, phi = 30, expand = 0.5, col = "red")
persp(x,y,z,theta = 10, phi = 30, expand = 0.5, col = "red")
fdejong = function(x, y) x^2 + y^2
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, fdejong)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 15, phi = 30, expand = 0.5, col = "red")
persp(x, y, z, theta = 80, phi = 30, expand = 0.5, col = "red")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "red")
f1 = function(x, y) x^2 + 3 * sin(y)
x <- seq(pi*-2,pi*2,length.out=100)
y <- seq(pi*-2,pi*2,length.out=100)
z <- outer(x^2,3* sin(y),`+`)
persp(x,y,z,theta = 90, phi = 30, expand = 0.5, col = "red")
persp(x,y,z,theta = 180, phi = 30, expand = 0.5, col = "red")
persp(x,y,z,theta = 120, phi = 30, expand = 0.5, col = "red")
par(mfrow=c(1,2))
persp(x,y,z,theta = 120, phi = 30, expand = 0.5, col = "red")
par(mfrow=c(1,2))
persp(x,y,z,theta = 180, phi = 30, expand = 0.5, col = "red")
persp(x,y,z,theta = 90, phi = 30, expand = 0.5, col = "red")
# Set up plot area with specified dimensions
par(mfrow=c(1,2), fig=c(4, 4))
persp(x, y, z, theta = 180, phi = 30, expand = 0.5, col = "red")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "red")
# Set up plot area with specified dimensions
par(mfrow=c(1,2), fig=c(2,2))
# Set up plot area with specified dimensions
par(mfrow=c(1,2))
persp(x, y, z, theta = 180, phi = 30, expand = 0.5, col = "red")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "red")
# Set up plot area with specified dimensions
par(mfrow = c(1,2), mar = c(5, 5, 3, 3), oma = c(0, 0, 2, 0))
persp(x, y, z, theta = 180, phi = 30, expand = 0.5, col = "red")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "red")
# Set up plot area with specified dimensions
par(mfrow = c(1,2))
persp(x, y, z, theta = 180, phi = 30, expand = 0.5, col = "red")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "red")
# Set up plot area with specified dimensions
par(mfrow = c(1,2))
persp(x, y, z, theta = 180, col = "red")
persp(x, y, z, theta = 90, col = "red")
# Set up plot area with specified dimensions
par(mfrow = c(1,2))
persp(x, y, z, theta = 180, phi = 30, col = "red")
persp(x, y, z, theta = 90, phi = 30, col = "red")
# Set up plot area with specified dimensions
par(mfrow = c(1,2))
persp(x, y, z, theta = 180, phi = 30, expand = 0.5, col = "lightblue")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "lightblue")
# Set up plot area with specified dimensions
par(mfrow = c(1,2))
persp(x, y, z, theta = 180, phi = 30, expand = 0.5, col = "lightblue")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "lightblue")
fdejong = function(x, y) x^2 + y^2
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, fdejong)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "red")
saveHTML({grad.desc(f1, pi * c(-2, -2, 2, 2), c(-2 * pi, 2))
},htmlfile = "GD_dos_minimos.html", img.name = "gd_dos_minimos", imgdir = "images/gd")
saveHTML({grad.desc(f1, pi * c(-2, -2, 2, 2), c(-2 * pi, -2))
},htmlfile = "GD_dos_minimos_2.html", img.name = "gd_dos_minimos", imgdir = "images/gd")
library(animation)
# ======= Representación de las funciones =======
# Función convexa
fdejong = function(x, y) x^2 + y^2
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, fdejong)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "red")
# Función con dos mínimos
f1 = function(x, y) x^2 + 3 * sin(y)
x <- seq(pi*-2,pi*2,length.out=100)
y <- seq(pi*-2,pi*2,length.out=100)
z <- outer(x^2,3* sin(y),`+`)
# Set up plot area with specified dimensions
par(mfrow = c(1,2))
persp(x, y, z, theta = 180, phi = 30, expand = 0.5, col = "lightblue")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "lightblue")
# ======== Animaciones =========
# Convexa
saveHTML({grad.desc(fdejong, c(-10,-10,10,10), c(8,8))
},htmlfile = "GD_convexo.html", img.name = "gd_convexa", imgdir = "imgs/gd")
# Convergencia a un mínimo
saveHTML({grad.desc(f1, pi * c(-2, -2, 2, 2), c(-2 * pi, 2))
},htmlfile = "GD_dos_minimos_1.html", img.name = "gd_dos_minimos1", imgdir = "images/gd")
# Cambiamos el punto inicial y la convergencia ahora es a otro mínimo, distinto al anterior
saveHTML({grad.desc(f1, pi * c(-2, -2, 2, 2), c(-2 * pi, -2))
},htmlfile = "GD_dos_minimos_2.html", img.name = "gd_dos_minimos2", imgdir = "images/gd")
library(animation)
# ======= Representación de las funciones =======
# Función convexa
fdejong = function(x, y) x^2 + y^2
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, fdejong)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "red")
# Función con dos mínimos
f1 = function(x, y) x^2 + 3 * sin(y)
x <- seq(pi*-2,pi*2,length.out=100)
y <- seq(pi*-2,pi*2,length.out=100)
z <- outer(x^2,3* sin(y),`+`)
# Set up plot area with specified dimensions
par(mfrow = c(1,2))
persp(x, y, z, theta = 180, phi = 30, expand = 0.5, col = "lightblue")
persp(x, y, z, theta = 90, phi = 30, expand = 0.5, col = "lightblue")
# ======== Animaciones =========
# Convexa
saveHTML({grad.desc(fdejong, c(-10,-10,10,10), c(8,8))
},htmlfile = "GD_convexo.html", img.name = "gd_convexa", imgdir = "imgs/gd")
# Convergencia a un mínimo
saveHTML({grad.desc(f1, pi * c(-2, -2, 2, 2), c(-2 * pi, 2))
},htmlfile = "GD_dos_minimos_1.html", img.name = "gd_dos_minimos1", imgdir = "images/gd")
# Cambiamos el punto inicial y la convergencia ahora es a otro mínimo, distinto al anterior
saveHTML({grad.desc(f1, pi * c(-2, -2, 2, 2), c(-2 * pi, -2))
},htmlfile = "GD_dos_minimos_2.html", img.name = "gd_dos_minimos2", imgdir = "images/gd")
